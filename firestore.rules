rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }

    function getId() {
      return request.auth.uid;
    }

    function getUserData() {
      return get(/databases/$(database)/documents/users/$(getId())).data;
    }

    function isSuper() {
      return isAuthenticated() && getUserData().role == 'super';
    }

    function isAdmin() {
      return isAuthenticated() && (getUserData().role == 'admin' || isSuper());
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    // --- Users Collection ---
    match /users/{userId} {
      allow read: if isOwner(userId) || isAdmin() || isAuthenticated();
      
      // Create: Only self
      allow create: if isOwner(userId);
      
      // Update: Self (no role change) OR Super (can change roles)
      allow update: if (isOwner(userId) && (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['role'])))
                    || isSuper();
        
      // Super can do anything
      allow write: if isSuper();
      
            // AI Profile Subcollection
      match /ai_profile/{pId} {
        allow read: if isSuper();
        allow write: if false; // Server-Side Only
      }

      // Notifications Subcollection
      match /notifications/{nId} {
        allow read: if isOwner(userId);
        allow update: if isOwner(userId);
        allow create: if false; // Only server creates notifications
        allow delete: if isOwner(userId);
      }
    }

    // --- Shelves Collection ---
    match /shelves/{shelfId} {
      allow read: if resource.data.isArchived != true || isAdmin();
      allow write: if isAdmin();
    }

    // --- Stories (Lore Items) Collection ---
    match /stories/{storyId} {
        // Read: Published, Public Domain, Admin, or Author
        allow read: if resource.data.status == 'published' || resource.data.isPublicDomain == true || isAdmin() || isOwner(resource.data.authorId);
        
        allow create: if isAuthenticated();
        
        // Update: 
        // 1. Owner can update everything
        // 2. Super can update everything
        // 3. Admin can ONLY update 'status' (Approval flow)
        allow update: if isOwner(resource.data.authorId)
                      || isSuper()
                      || (isAdmin() && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status']));

        // Delete: Owner or Super only (Admins should archive/unpublish, not delete user content)
        allow delete: if isOwner(resource.data.authorId) || isSuper();

        // Subcollections (Entries)
        match /entries/{entryId} {
            // Security: Entries are managed via Server API (add-entry.post.ts)
            // Deny Client SDK access to prevent tampering or IDOR.
            allow read, write: if false;
        }
    }

    // --- Books Collection ---
    match /books/{bookId} {
      allow read: if resource.data.status == 'published' || resource.data.isPublicDomain == true || isAdmin();
      allow write: if isAdmin();
    }

    // --- System/Stats Collection ---
    match /system/{docId} {
      allow read: if isAdmin(); // Only Admins/Super can see system stats (AI Usage)
      allow write: if false;    // Only Server-Side (dbAdmin) can write stats
    }


  }
}
